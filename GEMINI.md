-----

# Задание: Редактор конфигурации mediamtx на NiceGUI

## 1\. Цель

Разработать интерактивное веб-приложение на Python с использованием фреймворка **NiceGUI** для визуализации, редактирования и сохранения настроек сервера `mediamtx`. Приложение должно обеспечить интуитивно понятный интерфейс для управления сложной конфигурацией `mediamtx01.yml`.

## 2\. Контекст и источники данных

Приложение **не читает** `mediamtx01.yml` напрямую. Вместо этого, оно работает с набором `.json` файлов, которые уже были сгенерированы и разделены по категориям скриптом `main.py` (предоставлен ранее).

  * **Каталог данных (Источник):** `work/json/`
  * **Файлы для чтения и записи:**
      * `auth.json`
      * `paths.json`
      * `values_app.json`
      * `values_hls.json`
      * `values_pathDefaults.json`
      * `values_rtmp.json`
      * `values_rtsp.json`
      * `values_srt.json`
      * `values_webrtc.json`
  * **Конечный файл (Результат):** `work/mediamtx01.yml`
  * **Файл бэкапа:** `work/mediamtx01.yml.bak`

## 3\. Технологический стек

  * **Python 3.12+**
  * **NiceGUI**: Основной фреймворк для UI.
  * **PyYAML**: Для финальной генерации `.yml` файла.
  
## Виртуальная среда

### 1. В проекте используется пакет uv (https://github.com/astral-sh/uv)
#### Используй виртуальную среду: 
```bash
source .venv/bin/activate
```

#### Установите зависимости:
   ```bash
   uv add -r requirements.txt
   ```

## 4\. Основные требования к UI (NiceGUI)

Приложение должно представлять собой интерфейс с вкладками (`ui.tabs`).

### 4.1. Общие вкладки (Auth, RTSP, WebRTC, HLS, и т.д.)

  * Должны быть созданы вкладки для **каждого** файла `.json` из каталога `work/json/`, кроме `paths.json` (у него особый интерфейс).
  * **Названия вкладок:** "Auth", "RTSP", "WebRTC", "HLS", "RTMP", "SRT", "Path Defaults", "App (Основные)".
  * **Функционал:**
      * При запуске приложение читает соответствующий `.json` файл (например, `values_rtsp.json` для вкладки "RTSP").
      * Для **каждой** пары "ключ-значение" в JSON должен динамически создаваться элемент управления:
          * Для `boolean` значений (true/false) -\> `ui.checkbox`.
          * Для `list` (массивов) -\> `ui.textarea` или `ui.select(multiple=True, with_input=True)`.
          * Для `string` (строк) -\> `ui.input`.
          * Для `integer` (чисел) -\> `ui.number`.
      * Все поля должны быть редактируемыми и привязаны к модели данных (например, к словарю).

### 4.2. Специальная вкладка: "Paths" (Потоки)

Эта вкладка имеет самый сложный интерфейс и предназначена для управления `paths.json`.

  * **Интерфейс:** Вкладка должна содержать список раскрывающихся панелей (`ui.expansion` или `ui.card`).
  * **Список потоков:**
      * Приложение читает `paths.json`.
      * Для **каждого** ключа верхнего уровня (например, "avl", "vl", "ahd01H") создается одна панель `ui.expansion`.
      * **Заголовок панели:** Имя потока (например, `ui.expansion('avl')`).
  * **Содержимое панели:**
      * Внутри каждой панели должны быть редактируемые поля для **всех** параметров этого потока.
      * *Пример для "avl":* Должны быть поля `ui.textarea` для `runOnDemand`, `ui.checkbox` для `runOnReadyRestart` и `ui.input` для `runOnDemandStartTimeout`.
      * *Пример для "vl":* Должны быть поля `ui.input` для `source`, `ui.input` для `rtspTransport` и `ui.checkbox` для `sourceOnDemand`.

## 5\. Функционал: Добавление и управление потоками

На вкладке "Paths" должны быть реализованы следующие возможности:

### 5.1. Добавление нового потока

1.  На вкладке "Paths" должна быть кнопка (например, `ui.button(icon='add', text='Добавить поток')`).
2.  При нажатии появляется диалоговое окно (`ui.dialog`), которое запрашивает:
      * **Имя потока (Stream Name):** (Обязательно, например, `my_new_stream`).
      * **Тип потока (Stream Type):** Выбор из двух вариантов:
          * `Source` (на основе `source`)
          * `RunOnDemand` (на основе `runOnDemand`)
3.  После подтверждения:
      * В `paths.json` (пока только в памяти) добавляется новый ключ (например, `my_new_stream`).
      * В интерфейсе "Paths" появляется новая панель `ui.expansion('my_new_stream')`.
      * Внутри панели создается *предустановленный набор полей* в зависимости от выбранного типа:
          * **Если тип 'Source':** Создаются пустые поля для `source`, `rtspTransport`, `sourceOnDemand`.
          * **Если тип 'RunOnDemand':** Создаются пустые поля для `runOnDemand`, `runOnDemandRestart`, `runOnDemandStartTimeout`.
4.  Пользователь может сразу заполнить эти поля.

### 5.2. Редактирование и удаление потока

  * **Редактирование:** Пользователь может изменять любые параметры в полях внутри панели `ui.expansion`.
  * **Удаление:** В заголовке каждой панели потока должна быть кнопка "Удалить" (`ui.button(icon='delete')`), которая запрашивает подтверждение и, в случае успеха, удаляет поток из модели данных и интерфейса.

## 6\. Функционал: Сохранение конфигурации

В приложении (например, в заголовке или внизу) должна быть кнопка **"Сохранить" (`ui.button('Сохранить')`)**.

При нажатии на нее выполняется следующая последовательность действий:

1.  **Сбор данных:** Приложение собирает *актуальные данные* из всех полей ввода во *всех* вкладках.
2.  **Запись в JSON:**
      * Данные из каждой вкладки перезаписывают соответствующий `.json` файл в каталоге `work/json/`.
      * *Пример: Данные из вкладки "RTSP" сохраняются в `work/json/values_rtsp.json`.*
      * *Пример: Измененный список потоков из вкладки "Paths" сохраняется в `work/json/paths.json`.*
3.  **Создание бэкапа:**
      * Приложение проверяет наличие `work/mediamtx01.yml`.
      * Если файл существует, он копируется/переименовывается в `work/mediamtx01.yml.bak` (перезаписывая старый бэкап).
4.  **Сборка YAML:**
      * Приложение последовательно читает **все** `.json` файлы из `work/json/`.
      * Все данные из этих файлов объединяются в **один** большой словарь Python, сохраняя структуру `mediamtx01.yml` (где `paths` и `pathDefaults` являются ключами верхнего уровня, как и `rtsp`, `webrtc` и т.д.).
5.  **Запись YAML:**
      * Собранный словарь Python конвертируется в YAML-строку (с помощью `yaml.dump`).
      * Эта строка сохраняется в `work/mediamtx01.yml`.
6.  **Обратная связь:** Приложение должно уведомить пользователя об успешном сохранении (например, через `ui.notify('Конфигурация успешно сохранена!')`).

## 7\. Структура проекта (предполагаемая)

```
mediamtx-configurator/
├── src/
│   └── app.py        # <--- Ваш код NiceGUI
│   ├── main.py         # <--- Скрипт-парсер (уже есть)
├── work/
│   ├── mediamtx01.yml  # <--- Финальный результат (и исходник для main.py)
│   └── json/
│       ├── auth.json
│       ├── paths.json
│       ├── values_app.json
│       └── ... (остальные json файлы)
└── requirements.txt
```
